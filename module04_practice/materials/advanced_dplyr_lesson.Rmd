---
output:
  html_document:
    toc: yes
    toc_float: yes
---


# [SLCU R Course](https://tavareshugo.github.io/slcu_r_course/)

## Advanced data manipulation with R

In this module we are going to see how to do more advanced data manipulation
using `dplyr`, which is also a part of the `tidyverse` package family.

We will learn how to:

- Gather columns into rows (from wide to long format)
- Spread rows into columns (from long to wide format)
- Combine data sets
- Order rows by values of a column

First let's load the `tidyverse` package:

```{r, message = FALSE}
library(tidyverse)
```


###  Modifying the format of your data (`gather()` and `spread()`)

Often, we might have data in what is sometimes called a "wide" format. For example, 
in the following table we have the expression values of two genes (columns) in 
three samples (rows):

```{r}
# Create an example table
gene_expression <- tibble(sample = LETTERS[1:3],
                          gene1 = c(10, 100, 1000),
                          gene2 = c(20, 200, 2000))
gene_expression
```

This format is convenient if we wanted to plot the correlation of expression 
between the two genes in each sample, for example:

```{r}
ggplot(gene_expression, aes(gene1, gene2)) + geom_point()
```

But what if we wanted to plot the distribution of each gene's expression  
(with gene on the x-axis and expression value on the y-axis)?

We would instead want our table to be in a "long" format, like this:

```{r, echo = FALSE}
gene_expression %>% 
  gather(gene_id, expression, gene1:gene2) %>% 
  knitr::kable()
```

There is a pair of `dplyr` functions that can convert data from one format to 
the other. They are called `gather()` and `spread()`.

To "gather" data (i.e. from a "wide" to a "long" format), we do:

```{r}
gene_expression_long <- gene_expression %>% 
  gather(gene_id, expression, gene1, gene2)
gene_expression_long
```

`gather()` needs three things:

- the name of the new column containing the old column names is (in this case 
`gene_id`)
- the name of the new column containing the values of the old columns (in this 
case `expression`)
- the name of all the old columns we want to gather together

Notice that `gather()` takes care of filling in the `sample` column with the values 
corresponding to each new row of this table (in this case, each sample ID now appears 
twice). 

Now we can do the plot we wanted:

```{r}
ggplot(gene_expression_long, aes(gene_id, expression, colour = sample)) + 
  geom_point()
```


To "spread" the data (long --> wide), we would do:

```{r}
gene_expression_long %>% 
  spread(gene_id, expression)
```

`spread()` only needs two things:

- the name of the column that contains the values that will become the new column 
names
- the name of the column that contains the values of interest


### Combining data sets

Often, we might want to combine 2 data sets based on the values in one column. 
For this we can use several variations of the `*_join` functions.  

Let's say we have a second table with expression data for two more genes.

```{r}
# Create a second example table
gene_expression_more <- tibble(sample = LETTERS[2:4],
                          gene3 = c(30000, 3000, 300),
                          gene4 = c(40000, 4000, 400)) 
gene_expression_more
```

In this case, the `sample` column contains a common identifier between the two 
tables. However, we can see that not all samples are in common between the two 
tables. 

We can combine these two tables into a single table, retaining all samples, using 
the `full_join()` function:

```{r}
full_join(gene_expression, gene_expression_more, by="sample")
```

You can see that genes with no data for one of the samples were filled with `NA`.

All variations of the `*_join()` functions need three things:

- the name of the left data set
- the name of the right data set
- the name of the column to use in order to combine both data sets - more than 
one column can be used for joining.

Let's look at other variations of the `*_join()` functions:

- To keep only data for samples from the 1st data set, we can use 
`left_join()`:

```{r}
left_join(gene_expression, gene_expression_more, by="sample")
```

- To keep only data for samples from the 2nd data set, we can use `right_join()`:

```{r}
right_join(gene_expression, gene_expression_more, by="sample")
```

- To keep only data that is common between two data sets, we can use `inner_join()`:

```{r}
inner_join(gene_expression, gene_expression_more, by="sample")
```

- To keep only data that is in the left table but _not_ on the right table, 
we can use `anti_join()`:

```{r}
anti_join(gene_expression, gene_expression_more, by="sample")
```

These functions are very useful to compare big datasets:

- `inner_join()` is equivalent to the _intersect_ of the samples in two data sets.
- `full_join()` is equivalent to the _union_ of the samples in the two data sets.


### Sorting data

Sometimes, we might want to order our data based on the values in one column. 
For this, we can use `arrange()`:

```{r}
# Sort table by gene3's expression
arrange(gene_expression_more, gene3)
```

The default is to order values from low to high. 
If we want to order from high to low, we have to specify it using `desc()`:

```{r}
arrange(gene_expression, desc(gene1))
```


### Seperate one column into several ones

Sometimes, we might have different kind of information into one column and want to split it into several ones. 
For this, we can use `separate()`.

First, let's open a data with a column we would like to split:
```{r}
genotypes_to_split <- read_csv("../data/Genotypes_to_split.csv")
genotypes_to_split
```

Now let's separate the first column into 2 columns with information about thr mutation in one column and about the ecotype in the other. For this we use `separate()`:

```{r}
genotypes_split <- separate(genotypes_to_split, genotype, into=c("mutant","ecotype"), sep=" ")
genotypes_split
```
Note how `separate()` removed the original column and replaced it with the newly created ones.


`seperate()` function needs four things:

- the name of the data set
- the name of the column to separate
- the names of the columns to create (`into=c("mutant","ecotype")`) 
- the type of separator to split the column (`sep=" "`).


### Changing order of labels in plots

In the plot we previously did showing our gene expression distribution:

```{r}
ggplot(gene_expression_long, aes(gene_id, expression, colour = sample)) + 
  geom_point()
```

We can see that the order in which `gene_id` is plotted is alphabetical. This is 
the case, even if the order of the genes on the table is not alphabetical.

But what if we wanted _gene2_ to come first and _gene1_ to come after?

For this, we need to convert our `gene_id` variable to a special type called 
**factor**. Factors are a special type of character variables, where we define 
_levels_, which are the unique values we have in our variable. 

We can convert a variable to a factor using the `factor()` function:

```{r}
# Convert gene_id to a factor:
factor(gene_expression_long$gene_id)
```

We can see that our `gene_id` variable contains two levels, corresponding to 
each of the genes. The levels were automatically defined based on their alphabetical 
order. We can change this by specifying the levels ourselves:

```{r}
factor(gene_expression_long$gene_id, levels = c("gene2", "gene1"))
```

Once we convert our variable to a factor, we can use it to plot categorical variables 
in the order we wish:

```{r}
# Using mutate to modify the gene_id column into a factor with custom level order
# pipe it directly to ggplot to avoid creating intermediate variables
gene_expression_long %>% 
  mutate(gene_id = factor(gene_id, levels = c("gene2", "gene1"))) %>% 
  ggplot(aes(gene_id, expression, colour = sample)) +
  geom_point()
```


### Some key points to remember

- `dplyr` has many many useful functions to manipulate tables
- Today we have seen: 
    - `gather()` 
    - `spread()`
    - `left_join()`, `right_join()`, `full_join()`, `inner_join()` and `anti_join()`
    - `arrange()`
    - `separate()`
- Change the order of categorical variables in your graphs using `factor()`
- There are many `dplyr` functions we did not cover, but two additional useful 
ones are:
    - `rename()` to change column names
    - `top_n()` to filter the table based on the top/bottom entries of a column


### Futher reading and additional resources:

- [dplyr cheat sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)
- [data transformation chapter from 'R for Data Science'](http://r4ds.had.co.nz/transform.html)



