---
title: SLCU R Course
output:
  html_document:
    toc: yes
    toc_float: yes
---

[back to course home](https://tavareshugo.github.io/slcu_r_course/)

# Advanced data manipulation with R

In this module we are going to see how to do more advanced data manipulation
using `dplyr`, which is also a part of the `tidyverse` package family.

We will learn how to:

- Combine (join) data sets
- Gather columns into rows (from wide to long format)
- Spread rows into columns (from long to wide format)
- Order rows by values of a column

First let's load the `tidyverse` package:

```{r, message = FALSE}
library(tidyverse)
library(forcats)
```

We will use example datasets that come with R (no need to read it from anywhere).


## Combining datasets (`*_join()`)

Often when analysing data we have many tables containing different types of related information. So, to answer a particular question it is a common task to combine multiple tables by a certain column or columns. The `dplyr` package contains a family of `*_join` functions that allow us to this.

All variations of the `*_join()` functions need three things:

- the name of the first (left) data set
- the name of the second (right) data set
- the name of the column to use in order to combine both data sets - more than one column can be used for joining.

Let's first have a look at the `full_join()` function, it will return all rows and all columns from both datasets. 
We will use 2 built-in datasets to illustrate its work:

- `band_members` 
```{r}
band_members
```
- `band_instruments`
```{r}
band_instruments
```
Say, we want to combine data form this two tables into one, so that we have information about name, band and instrument in one place:

```{r full_join}
band_members %>% full_join(band_instruments)
```
The alternative syntax, without pipes would be:
```{r full_join2}
full_join(band_members, band_instruments)
```
You can see that people with no information about their band or instrument have 'NA's now in the respective column. Here we did not have to specify the column we wanted to join by because R was very smart and picked the only possible option - joining by the `name` column. Though in more complex scenarious, when there are more than 1 columns with the same name between 2 datasets - you should specify which one you would like to join by (or both). 

Let's look at other variations of the `*_join()` functions:

- To keep only data from the ``band_members`` data set (left), we can use `left_join()`:

```{r}
left_join(band_members, band_instruments)
```

- To keep only data for samples from the ``band_instruments`` data set (right), we can use `right_join()`:

```{r}
right_join(band_instruments, band_members)
```

- To keep only data that is common between two data sets, we can use `inner_join()`:

```{r}
inner_join(band_members, band_instruments)
```
So, the result does not have NA's any more

- To keep only data that is in the left table but _not_ on the right table, we can use `anti_join()`:

```{r}
anti_join(band_members, band_instruments)
```
... and the other way around:
```{r}
anti_join(band_instruments, band_members)
```

These functions are very useful to compare big datasets:

- `inner_join()` is equivalent to the _intersect_ of the samples in two data sets.
- `full_join()` is equivalent to the _union_ of the samples in the two data sets.


##  Reshapping data (`gather()` and `spread()`)

Often, we might have data in what is sometimes called a "wide" format. 

For example, in the `iris` dataset, we have classic data of petal and sepal 
lengths and widths in three Iris species. 
In this table, each organ's measurement has its own column:

```{r}
# For convenience convert the iris dataset to a tibble (so it doesn't print out of the screen!)
iris <- as_tibble(iris)
iris
```

This format is convenient if we wanted to plot the correlation between these 
measurements, for example:

```{r}
ggplot(iris, aes(Petal.Length, Sepal.Length, colour = Species)) + 
  geom_point()
```

But what if we wanted to plot the distribution (as boxplots) of each organ's length
and width?

We would instead want our table to be in a "long" format, like this:

```{r, echo = FALSE}
set.seed(11)
iris %>% 
  gather(trait, size, -Species) %>% 
  sample_n(10) %>% 
  arrange(Species, trait) %>% 
  knitr::kable()
```

There is a pair of `dplyr` functions that can convert data from one format to 
the other. They are called `gather()` and `spread()`.

Here is a schematic representation of what these two functions do:

![](http://www.datacarpentry.org/R-ecology-lesson/img/gather_data_R.png)

![](http://www.datacarpentry.org/R-ecology-lesson/img/spread_data_R.png)

To "gather" data (i.e. from a "wide" to a "long" format), we do:

```{r}
iris_long <- iris %>% 
  mutate(flower_id = 1:n()) %>%         # Make an identifier for each flower
  gather(trait, size, -Species, -flower_id)
iris_long
```

`gather()` needs three things:

- the name of the new column containing the old column names (in this case 
`trait`)
- the name of the new column containing the values of the old columns (in this 
case `size`)
- the name of all the old columns we want to gather together

Notice that `gather()` takes care of filling in the `id` column with the values 
corresponding to each new row of this table (in this case, each flower ID now appears 
four times - because we have four measurements per flower). 

Now we can do the plot we wanted:

```{r}
ggplot(iris_long, aes(trait, size, fill = Species)) + 
  geom_boxplot()
```

To "spread" the data (long --> wide), we would do:

```{r}
iris_long %>% 
  spread(trait, size)
```

`spread()` only needs two things:

- the name of the column that contains the values that will become the new column 
names
- the name of the column that contains the values of interest


## Separate one column into several ones

Sometimes, we might have different kind of information in one column and want 
to split it into several ones. For this, we can use `separate()`.

For example, in the `iris_long` object, we might want to separate the `trait` 
column into a column indicating the flower organ (petal or sepal) and another 
one indicating the type of measurement (width or length). 

These two pieces of information are separated by a `.`:

```{r}
unique(iris_long$trait)
```

Using `separate()`, we can separate the values in this column into two columns:

```{r}
# Automatic guess
iris_long %>% 
  separate(trait, c("organ", "measure"))
```

Note how `separate()` removed the original column and replaced it with the newly 
created ones.

With this new trick, we can now create a slightly different plot:

```{r}
iris_long %>% 
  separate(trait, c("organ", "measure")) %>% 
  ggplot(aes(Species, size, fill = measure)) +
  geom_boxplot() +
  facet_grid( ~ organ)
```


In the code above, we let `separate()` "guess" what the separator was (by default 
it finds any non-alphanumeric character). But we can be explicit, by telling it 
the separator is a `.`. However, the dot `.` symbol is a special character used in 
_regular expressions_. This is beyond the scope of this course, but in summary,
regular expressions allow us to find patterns in character strings. (see 
[here](http://r4ds.had.co.nz/strings.html#matching-patterns-with-regular-expressions) 
if you want to know more about them - they can be very useful to match patterns 
in our data!) 

Because of this special use of the dot `.` symbol, we need to tell the function 
to ignore the special meaning of the dot `.` symbol by prefixing it with `\\`:

```{r}
iris_long %>% 
  separate(trait, c("organ", "measure"), 
           sep = "\\.", 
           remove = FALSE)
```

Notice how above we also retained the original column name.

Note: the reverse of `separate()` is `unite()`:

```{r}
iris_long %>% 
  separate(trait, c("organ", "measure")) %>% 
  unite(trait, organ, measure, sep = ".")
```


## Changing order of labels in plots

In the following boxplot

```{r}
ggplot(iris, aes(Species, Sepal.Width)) + 
  geom_boxplot()
```

the order in which `Species` are plotted is alphabetical. This is the case, even 
if the order of the Species on the table was not alphabetical.

But what if we wanted a different order?

For this, we need to convert our `Species` variable to a special type called 
**factor**. Factors are a special type of character variables, where we define 
_levels_, which are the unique values we have in our variable. 

We can convert a variable to a factor using the `factor()` function:

```{r}
# Convert Species to a factor:
factor(iris$Species)
```

We can see that our `Species` variable contains three levels, corresponding to 
each of the species. The levels were automatically defined based on their alphabetical 
order. We can change this by specifying the levels ourselves:

```{r}
factor(iris$Species, levels = c("versicolor", "virginica", "setosa"))
```

Once we convert our variable to a factor, we can use it to plot categorical variables 
in the order we wish:

```{r}
# Using mutate to modify the Species column into a factor with custom level order
iris %>% 
  mutate(Species = factor(Species, levels = c("virginica", "versicolor", "setosa"))) %>% 
  ggplot(aes(Species, Sepal.Width)) + 
  geom_boxplot()
```

What if we wanted to order the species based on their Sepal.Length?
The `forcats` package (part of `tidyverse`) has a very useful function 
for this, `fct_reorder()`!

```{r}
iris %>% 
  mutate(Species = fct_reorder(Species, Sepal.Width)) %>% 
  ggplot(aes(Species, Sepal.Width)) + 
  geom_boxplot()
```


## Sorting data

Sometimes, we might want to order our data based on the values in one column. 
For this, we can use `arrange()`:

```{r}
iris %>% 
  arrange(Petal.Width)
```

The default is to order values from low to high. 
If we want to order from high to low, we have to specify it using `desc()`:

```{r}
iris %>% 
  arrange(desc(Petal.Width))
```



## Key points to remember

- `dplyr` has many many useful functions to manipulate tables
- Today we have seen: 
    - `left_join()`, `right_join()`, `full_join()`, `inner_join()` and `anti_join()`
    - `gather()` 
    - `spread()`
    - `arrange()`
    - `separate()`
- Change the order of categorical variables in your graphs using `factor()` and `fct_reorder()`
- There are many `dplyr` functions we did not cover, but two additional useful 
ones are:
    - `rename()` to change column names
    - `top_n()` to filter the table based on the top/bottom entries of a column


### Further reading and additional resources:

- [dplyr cheat sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)
- [data transformation chapter from 'R for Data Science'](http://r4ds.had.co.nz/transform.html)


-------

[back to course home](https://tavareshugo.github.io/slcu_r_course/)


