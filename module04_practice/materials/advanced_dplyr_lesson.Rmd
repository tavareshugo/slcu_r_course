---

output: html_document
---


# [SLCU R Course](https://tavareshugo.github.io/slcu_r_course/)

## Advanced data manipulation with R - material

In this module we are going to see how to do more advanced data manipulation
using `dplyr`, which is also a part of the `tidyverse` package family.

We will learn how to:

- Gather columns into rows (from wide to long format)
- Spread rows into columns (from long to wide format)
- Combine data sets
- Order rows by values of a column

First let's load the `tidyverse` package:

```{r, message = FALSE}
library(tidyverse)
```


###  Modifying the format of your data (`gather()` and `spread()`)

Often, we might have data in what is sometimes called a "wide" format. For example, 
in the following table we have the expression values of two genes (columns) in 
three samples (rows):

```{r}
# Create an example table
gene_expression <- tibble(sample = LETTERS[1:3],
                          gene1 = c(10, 100, 1000),
                          gene2 = c(20, 200, 2000))
gene_expression
```

This format is convenient if we wanted to plot the correlation of expression 
between the two genes in each sample, for example:

```{r}
ggplot(gene_expression, aes(gene1, gene2)) + geom_point()
```

But what if we wanted to plot the distribution of each gene's expression  
(with gene on the x-axis and expression value on the y-axis)?

We would instead want our table to be in a "long" format, like this:

```{r, echo = FALSE}
gene_expression %>% 
  gather(gene_id, expression, gene1:gene2) %>% 
  knitr::kable()
```

There is a pair of `dplyr` functions that can convert data from one format to 
the other. They are called `gather()` and `spread()`.

To "gather" data (i.e. from a "wide" to a "long" format), we do:

```{r}
gene_expression_long <- gene_expression %>% 
  gather(gene_id, expression, gene1, gene2)
gene_expression_long
```

`gather()` needs three things:

- the name of the new column containing the old column names is (in this case 
`gene_id`)
- the name of the new column containing the values of the old columns (in this 
case `expression`)
- the name of all the old columns we want to gather together


Now we can do the plot we wanted:

```{r}
ggplot(gene_expression_long, aes(gene_id, expression, colour = sample)) + 
  geom_point()
```


To "spread" the data (long --> wide), we would do:

```{r}
gene_expression_long %>% 
  spread(gene_id, expression)
```

`spread()` only needs two things:

- the name of the column that contains the values that will become the new column 
names
- the name of the column that contains the values of interest


###  Combining data sets

Often, we might want to combine 2 data sets based on the values in one column. For this we can use several variation of the `join` function.  

Let's say we have a second table with expression data for extra genes.


```{r}
# Create a second example table
gene_expression_more <- tibble(sample = LETTERS[2:4],
                          gene3 = c(30000, 3000, 300),
                          gene4 = c(40000, 4000, 400)) 
gene_expression_more
```

If we want to combine this data set with the previous table, keeping only data for samples from the 1st data set, we can use `left_join()`:

```{r}
gene_expression_combined_left <- left_join(gene_expression,gene_expression_more,
                                           by="sample")
gene_expression_combined_left
```

All variation of `join()` need three things:

- the name of the left data set
- the name of the right data set
- the name of the column to use in order to combine both data sets

Note that it adds `NA` if there is no data for a sample in the second data set.


To keep only data for samples from the 2nd data set, we can use `right_join()`:

```{r}
gene_expression_combined_right <- right_join(gene_expression,gene_expression_more,
                                           by="sample")
gene_expression_combined_right
```


To keep data for all samples, we can use `full_join()`:

```{r}
gene_expression_combined_full <- full_join(gene_expression,gene_expression_more,
                                           by="sample")
gene_expression_combined_full
```



We might also want to know what is common between two data sets. To keep samples (from one column) that are in the two data sets, we can use `inner_join()`:

```{r}
gene_expression_combined_semi <- inner_join(gene_expression,gene_expression_more,
                                           by="sample")
gene_expression_combined_semi
```

Using `inner_join()` would be the equivalent of doing the intersect of the samples in the two data sets.
Using `full_join()` would be the equivalent of doing the union of the samples in the two data sets.

###  Sorting data

Sometimes, we might want to order our data based on the values in one column. For this, we can use `arrange()`:

```{r}
gene_expression_more_ordered_gene3 <- arrange(gene_expression_more, gene3)

gene_expression_more_ordered_gene3
```


The default is to order values from low to high. If we want to order from high to low, we have to specify it using `desc()`:

```{r}
gene_expression_descending_gene1 <- arrange(gene_expression, desc(gene1))

gene_expression_descending_gene1
```



### Some key points to remember

- `dplyr` has many many useful functions to manipulate tables
- Today we have seen: 
  - `gather()` 
  - `spread()`
  - `left_join()`, `right_join()`, `full_join()` and `inner_join()`
  - `arrange()`


### Futher reading and additional resources:

- [dplyr cheat sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)
- [data transformation chapter from 'R for Data Science'](http://r4ds.had.co.nz/transform.html)



