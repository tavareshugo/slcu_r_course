---
title: "Data Exploration with R"
output: html_document
---
In this lesson we will learn how to explore tabular data, perform basic sanity checks and do beautiful visualizations with [``ggplot2``](http://ggplot2.org/).

## Prerequsites 

First we will install some R packages containing functions we need. This can be done with ``install.packages()`` function.

```{r install packages, eval = FALSE}
install.packages("visdat")
install.packages("tidyverse")
install.packages("plotly")
install.packages("ggplot2")
```
Once the packages are installed, we can load them in the current R session with ``library()`` function. 

```{r load packages, eval = TRUE, echo = FALSE}
library(tidyverse)
library(visdat)
library(plotly)
library(ggplot2)
```

Now our work space is ready, the only thing missing - is the actual data set that we want to explore and visualize. For this lesson we will use a slightly simplified version of a data set published by [Burghard et al 2015](http://datadryad.org/resource/doi:10.5061/dryad.65d76). 

## Read the data

The simplified version of the data set can be found in the ``course_data`` folder (`burghardt_et_al_2015_expt1.csv`). Run the command below to read the data. We will store it in a variable called ``x``. 

```{r read data}
x <- read.csv("../course_data/burghardt_et_al_2015_expt1.csv") %>%  as.tibble()
```

## Look at the data

To get a glimpse of the data, we can just type in the console the name of the variable we have stored it in (`x`).

```{r head x}
x
```
This will show you first 10 lines and 6 columns of the data. 

\newline 

> **Challenge:** How many rows and columns does our data set contain?

There are other ways to visually inspect your data:

- with ``View()`` function you can have access to an interactive table, where you can sort, filter and search your data set with keywords.

```{r View, eval = FALSE}
View(x)
```
- with ``str()`` function you can get access to a structure of you data sets.

```{r str}
str(x)
```
> **Challenge** what types of variables do we have in our data set? what could they mean?  What type of variable is "bolt"? How about "temperature"?

- ``dim()`` returns basic dimensions of your data set, i.e. numbers of rows and columns.
```{r dim}
dim(x)
```

- finally, for numeric variables it is convenient to use ``summary()`` function, which generates basic stats for each numeric column.

```{r summary}
summary(x)
```

So far, we have already used a handful of R functions, though we have just barely started:

- ``install.packages()``
- ``library()``
- ``read.csv()``
- ``View()``
- ``str()``
- ``summary()``
- ``dim()``

Of course, it is difficult to memorize all the function names, what they are doing and how you should use them. Luckily, R has very convenient built-in help. To use it, type name of a function or any other object you are interested it preceded by `?`

```{r get help}
?summary
```

R help might seem cryptic at first, but you will get used to it, you can always scroll down to the 'examples' section and try running some of them yourself to get an idea of what the function in question is capable of.

> **Challenge** what does ``round()`` function do? 

> **Challenge** can you specifically look at the end of your data set instead of it's beginning? How would you do it in R? (hint: ``?tail``)

## Visual representation of your data

To get a bird-eye view at the data, to identify its structure and potential problems we can simply plot it in Rothko style using ``vis_dat()`` function.

```{r}
vis_dat(x)
```

> **Challenge** what is the most common data type in our data set ? Can you spot any potential problems?

### Missing values

You might have noticed that some of the cells are plotted in gray - these indicate missing values. Missing values can occur in a data set when a certain observation was not collected and cause potential problems in the downstream analysis if we are not careful. There are a couple of strategies how to deal with missing values:

- remove rows with missing values completely (the safest option, though can result in substantial data loss);
- ignore missing values when you can (can you?);
- impute value based on surrounding values (the most risky).

To stay on the safe side now, we will simply remove all the rows with missing values from our beloved `x` data set.

```{r drop missing}
x <- x %>% drop_na()
```

> **Challenge** How many rows are left in the data set after we have dropped missing values? 


## Plots! Plots! Plots!

Now, once we have learned some basics of our data set, we will go straightly to plotting to get even more insights. We will use plotting 
grammars from ggpplot2 package. Plotting grammars might sound scary, but just think about them as simple building blocks of a plot. By combining and layering several blocks we can create our dream plot for a dream paper or just a lab meeting.

To build a graph we need several blocks:

- data
- aesthetics
- geometric object (type of a plot)
- statistical transformations
- coordinate system
- positional adjustments
- faceting

Let's focus on the first three: data, aesthetics and geometric object. 

- **data** - well, this is obvious, we need some data;
- **geom_objects** - this is the most crucial part, actual objects that we put on a plot. A plot must have at least one `geom_object`. Examples include:
    - points (`geom_point` for scatter plots, dot plots)
    - lines (`geom_line` for trend lines, time series)
- **aesthetics** - ~ something we can see, e.g: position, colour, shape, line type, size. Aesthetics can be set with `aes()` function. Note, different ``geom_`` objects can understand only a subset of aesthetics. For details, check help. (``?geom_line``)    

Everyone, except excel, likes box plots, so we will start by plotting `days. to.flower` variable measured for different genotypes. ``ggplot()`` initializes a plot, we also give it our `x` data set and specify aesthetics that should be common for the whole plot, in our case - names for x and y axis.

```{r}
ggplot(x, aes(genotype, days.to.flower))

```
 
Next, we can layer ``geom_object`` on top of the created canvas by just adding ``geom_boxplot()``. 

```{r}
ggplot(x, aes(genotype, days.to.flower)) +
    geom_boxplot()
```

> **Exercise:** can you make a violin plot instead? (hint: ``?geom_violin``)

```{r}
ggplot(x, aes(genotype, days.to.flower)) +
  geom_violin()
```

Let's be honest, the plot looks pretty ugly. We want to add some colour. Colour sound like it should belong to aesthetics, so we put it inside ``aes()`` function. Note, you usually don't need to worry about colours, ``ggplot`` does it for you by sampling from its default colour palettes.
In this case we want different genotypes to be coloured differently.


```{r}
ggplot(x, aes(blade.length.mm, rosette.leaf.num, colour = genotype)) + geom_point()
```

Pretty! Let's now layer a couple of ``geom_objects`` on the same plot. Say, we want to have points for actual values overlayed with box plots:

```{r}
ggplot(x, aes(genotype, rosette.leaf.num, colour = genotype)) +
    geom_jitter() +
  geom_boxplot(alpha = 0.2)
```

Note, in this case we have supplied ``geom_boxplot`` with additional aesthetics parameter `alpha`, and only boxes got affected, not the whole plot. This is an example how you could control specific aesthetics of individual `geom_objects`.

Now, let's assume we are particularly interested in the relationship between number of rosette leafs and blade length in mm per genotype. To visualize the relationship we generate a scatter plot.

```{r complex plot}
ggplot(x, aes(blade.length.mm, rosette.leaf.num, colour = genotype)) +
    geom_point()
```

It is pretty, though messy. What if we wanted to isolate each genotype in individual plots? It is easy with ggplot2, we need another layer in our plot, `facet`, which tells R to plot genotypes separetely and arrange them in a ribbon, side by side.

```{r decomposed plot}
ggplot(x, aes(blade.length.mm, rosette.leaf.num, colour = genotype)) +
    geom_point() +
    facet_wrap(~genotype)
```

So much better. But even this is not the limit. We can easily turn our plot in interactive mode, by just wrapping in a special  ``ggplotly()`` function.

```{r go interactive}
p1 <- ggplot(x, aes(blade.length.mm, rosette.leaf.num, colour = genotype)) + 
  geom_point() +
  facet_wrap(~genotype)
plotly::ggplotly(p1)
```
